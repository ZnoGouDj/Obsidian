# Замыкания

Замыкание — механизм JS, с помощью которого мы можем в рамках какой-то функции замкнуть какое-то значение и использовать его на функции, которая где-то внутри используется. 

То есть мы можем создать ОДНУ функцию, внутри нее создать какую-то переменную, из этой функции вернуть ДРУГУЮ функцию, эту переменную использовать внутри вложенной функции и она замкнет в себе значение функции их вышестоящего скоупа.

При этом сколько бы раз мы эту верхнеуровневую функцию не вызывали, она внутри себя будет замыкать какбы новое значение, при этом дочерняя функция будет использовать значение из вышестоящего скоупа верхней функции.



## эмуляция private методов с помощью замыкания

Языки типа Java дают возможность создавать приватные методы, которые могут быть вызваны только методами того же класса, в котором они объявлены.  JS такой возможности не дает, но может эмулировать. 

```js
var Counter = (function() {
	var privateCounter = 0;
	function changeBy(val) {
		privateCounter += val;
	}
	return {
		increment: function() {
			changeBy(1);
		},
		decrement: function() {
			changeBy(-1);
		},
		value: function() {
			return privateCounter;
		}
	}
})();

console.log(Counter.value()); // 0
Counter.increment();
Counter.increment();
console.log(Counter.value()); // 2
Counter.decrement();
console.log(Counter.value()); // 1
```

Тут мы создаем единое окружение для трех функций (increment, decrement, value). Оно создается в теле анонимной функции, которая исполняется в момент описания. 
Приватные элементы - privateCounter и changeBy(val). Напрямую они недоступны, поэтому надо будет к ним обращаться тремя публичными функциями. Они являются замыканиями, использующими общий контекст, и имеют доступ к privateCounter и changeBy.


Также можно запихнуть функцию в переменную и использовать за счет этого несколько счетчиков:

```js
var Counter1 = makeCounter();
var Counter2 = makeCounter();
alert(Counter1.value()); /* Alerts 0 */
Counter1.increment();
Counter1.increment();
alert(Counter1.value()); /* Alerts 2 */
Counter1.decrement();
alert(Counter1.value()); /* Alerts 1 */
alert(Counter2.value()); /* Alerts 0 */
```
Счетчики работают независимо, потому что у каждого при создании также создался свой контекст.