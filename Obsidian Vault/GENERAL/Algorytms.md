(Алгоритмы)

Это набор последовательных действий, решающий какую-то задачу. 
В принципе любой фрагмент кода можно назвать алгоритмом. 

[Big O Notation](#big_o_notation)
[Linear Search](#linear_search)
[Binary Search](#binary_search)
[Selection Sort](#selection_sort)
[Bubble Sort](#bubble_sort)
[Quick Sort](#quick_sort)
[Breadth-first search](#breadth_first_search)


### BIG_O_NOTATION ###
Скорость работы алгоритма описывается с помощью **большого О()**.
В скобках указывается количество операций, за которое этот алгоритм приходит к финальному результату. Причем указывается всегда НАИХУДШИЙ сценарий.

Одни алгоритмы эффективнее других, причем эффективность не всегда равна скорости работы алгоритма, поскольку в некоторых ситуациях более медленный алгоритм может оказаться на определенной выборке данных более эффективным. 

![[big-o-notation.png]]

На рисунке - основные примеры функций, которыми описывается сложность алгоритмов.
По оси X - количество операций. По оси Y - время.

<p style="text-align: center; font-size: large; font-weight: bold;">Example</p>

Допустим нам нужно найти конкретный элемент в массиве.

ОДИН из подходящих алгоритмов - **линейный поиск**:

### Linear_search ###
Мы начинаем с первого элемента и сравниваем каждый элемент с нужным.
В лучшем случае мы найдем элемент за 1 операцию, если он находится в списке первым.
В худшем - элемент будет в самом конце списка. И нам нужно будет обойти весь массив. 

```js
const arr = [7, 6, 1, 4, 0, 2, 3, 5, 8, 5]

function linearSearch(arr, item) {
	for (let i = 0; i < arr.length; i++) {
		if (arr[i] === item) {
			return i;
		}
	}
	return null;
}
```

Оценка сложности производится по худшему сценарию. Поэтому сложность данного алгоритма будет O(n), где n - количество элементов в массиве. 

ДРУГОЙ подходящий алгоритм - **бинарный поиск**:

### Binary_search ###
Он работает в разы быстрее, но подразумевается что массив отсортирован.
**Пример с телефонной книгой из CS50** (открываем посередине, отрываем ненужное, повторить до нахождения)
Таким образом, с каждым шагом мы отсеиваем ПОЛОВИНУ ненужных результатов. 

```js
const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

function binarySearch(arr, item) {
	let start = 0;
	let end = arr.length;
	let middle;
	let found = false;
	let position = -1;
	
	while(found === false && start <= end) {
		middle = Math.floor((start + end) / 2);
		if (arr[middle] === item) {
			found = true;
			position = middle;
			return position;
		}
		if (item < arr[middle]) {
			end = middle - 1;
		} else {
			start = middle + 1;
		}
	}
	return position;
}
```
BONUS - recursive binary search:
```js
function recursiveBinarySearch(array, item, start, end) {
	let middle = Math.floor((start + end) / 2);
 	if (item === array[middle]) {
		return middle;
	}
	if (item < array[middle]) {
		return recursiveBinarySearch(array, item, start, middle - 1);
	} else {
		return recursiveBinarySearch(array, item, middle + 1, end);
	}
}
```

Сложность такого алгоритма - O(log2n) или О большое от логарифм N по основанию 2. 
Логарифм - обратная возведению в степень функция. 

Теперь если сравнивать эти алгоритмы, то получим:
<div style="display: flex; justify-content: center;">
<table border="1">
<tbody style="text-align: right;">
<tr>
<td></td>
<td>Линейный</td>
<td>Бинарный</td>
</tr>
<tr>
<td>100 элементов</td>
<td>100 мс</td>
<td>7 мс</td>
</tr>
<tr>
<td>10 000 элементов</td>
<td>10 сек</td>
<td>14 мс</td>
</tr>
<tr>
<td>1 000 000 элементов</td>
<td>11 дней</td>
<td>32 мс</td>
</tr>
</tbody>
</table>
</div>

Но важно понимать, что бинарный алгоритм работает только с отсортированным списком! 
И в несортированном массиве мы ничего не найдем. 
И сортировать перед поиском тоже не имеет смысла, поскольку время сортировки ГОРАЗДО длительнее, чем время работы линейного поиска. 

### Selection_Sort ###
(Сортировка выбором)

Есть массив неупорядоченных элементов.
Мы находим МИНИМАЛЬНЫЙ и меняем местами с 1м элементом. 
Затем снова находим ДРУГОЙ МИНИМАЛЬНЫЙ и меняем местами со 2м элементом (и тд)

```js
function selectionSort(array) {
	for (let i = 0; i < array.length; i++) {
		let indexMin = i;
		for (let j = i + 1; j < array.length; j++) {
			if (array[i] < array[indexMin]) {
				indexMin = j;
			}
		}
		let tmp = array[i];
		array[i] = array[indexMin];
		array[indexMin] = tmp;
	}
	return array;
}
```

Сложность - O(n*n)

### Bubble_Sort ###
(Сортировка пузырьком)

Очень известный и очень неэффективный лол.

Принцип - пробегаемся по всему массиву и сравниваем попарно лежащие элементы. 
Если следующий элемент массива меньше, чем предыдущий - меняем местами. 
И получается такое "всплытие" - самый БОЛЬШОЙ элемент с каждой итерацией потихоньку всплывает наверх. 

```js
function bubbleSort(array) {
	for (let i = 0; i < array.length; i++) {
		for (let j = 0; j < array.length; j++) {
			if (array[j + 1] < array[j]) {
				let tmp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = tmp;
			}
		}
	}
	return array;
}
```

Сложность - O(n*n)

### Quick_Sort ###
(Быстрая сортировка)

Один из самых эффективных
Сложность O(log2n * n) или О большое от логарифм по основанию 2 от N умноженное на N.

Если сравнивать скорость:
<div style="display: flex; justify-content: center;">
<table border="1">
<tbody style="text-align: right;">
<tr>
<td></td>
<td>O(log2n * n)</td>
<td>O(n*n)</td>
</tr>
<tr>
<td>n = 128</td>
<td>0.6 секунд</td>
<td>16 секунд</td>
</tr>
<tr>
<td>n = 1024</td>
<td>10 секунд</td>
<td>17 минут</td>
</tr>
</tbody>
</table>
</div>
Одна операция условно за 1мс.

Работает по принципу "РАЗДЕЛЯЙ И ВЛАСТВУЙ". 
Мы разделяем массив на подмассивы. 
И каждый раз рекурсивно мы выбираем опорный элемент каждого массива (можно случайный, но чаще всего берут центрально)
Пробегаемся по массиву, и все элементы, которые по значению меньше, чем ОПОРНЫЙ, добавляем в ОДИН МАССИВ, которые больше - В ДРУГОЙ МАССИВ.
Получаем два массива - с меньшими и большими, чем опорное число. 
Затем для каждого из этих массивов выполняется такая же операция. 
И это продолжается до тех пор, пока длина массива не будет === 1.
Затем останется только СКЛЕИТЬ массивы-малютки в один большой массив. 

```js
function quickSort(array) {
	if (array.length <= 1) {
		return array;
	}
	let currentIndex = Math.floor(array.length / 2); // currentIndex - опорный элемент
	let current = array[currentIndex];
	let less = [];
	let greater = [];
	for (let i = 0; i < array.length; i++) {
		if (i === currentIndex) continue;
		if (array[i] < current) {
			less.push(array[i]);
		} else {
			greater.push(array[i]);
		}
	}
	return [...quickSort(less), current, ...quickSort(greater)]
}
```

### Breadth_first_search ###
Поиск в ширину. ГРАФЫ.

Граф - абстрактная структура данных, представляющая собой множество вершин и набор ребер (соединения между парами вершин). 
То есть это (например) КАРТА, на которой есть города и города соединены маршрутами.
Маршруты тогда получаются ребра, а города - вершины. 

Ребра бывают однонаправленными и двунаправленными, то есть из точки А можно попасть в точку Б и наоборот. 

*но сейчас будем считать что однонаправленные, и обратно возвращаться мы не можем*
И будем разбирать задачу - определить кратчайший путь из А в Б, если таковой имеется. 

```js
const graph = {}
// в коде граф выражается так
// создается объект, поля которого - вершины
// и каждое поле равняется массиву вершин, в которые есть ПУТЬ 
graph.a = ['b', 'c']; // то есть из А мы имеем путь в Б и С
graph.b = ['f']; // из Б имеем путь в Ф и т.д.
graph.c = ['d', 'e'];
graph.d = ['f'];
graph.e = ['f'];
graph.f = ['g'];
```