(OOP)
Изначально все программы писались <span style="font-weight: bold; color: mediumvioletred;">процедурным</span>  подходом.
![[procedure_paradigm.png]]
Затем, когда программы начали разрастаться, этот подход более не работал, так как сложно всем управлять когда ТАК МНОГО кода. Сложно конфигурировать приложения, управлять сущностями, делать декомпозицию и тд.

Поэтому был придуман <span style="font-weight: bold; color: deepskyblue;">объектно-ориентированный</span> подход. Этот подход представлен в виде совокупности объектов, каждый из которых является экземпляром какого-то класса, а классы образуют иерархию наследования.

![[classesVSobjects.png]]

То есть <span style="font-weight: bold; color: #FFB514;">класс</span> – некоторое описание характеристик, а <span style="font-weight: bold; color: deepskyblue;">объекта</span> – конкретный экземпляр, у которого каждая характеристика имеет какое-то значение.

<span style="font-weight: bold; color: mediumvioletred;">Свойства</span> – данные объекта (имя, возраст и тд). 
<span style="font-weight: bold; color: #FFB514;">Методы</span> – способность что-то делать.

## Основные концепции
1) **Инкапсуляция** (сокрытие) позволяет взаимодействовать с тем, чем дают (что открыто) и не думать о сложных процессах внутри.

![[incapsul.png]]

2) **Наследование** – способность писать классы на основе уже существующего.

![[inheritance.png]]

3) **Полиморфизм** — взаимозаменяемость объектов с одинаковым интерфейсом.  

Или возможность использования экземпляра класса-наследника там, где требуется экземпляр базового класса. (Это определение можно расширить и на интерфейсы, если учесть, что интерфейс — это чисто абстрактный класс.)

![[polymorph.png]]


## Агрегация и композиция
**Композиция**. В классе Автомобиль создается класс Двигатель и 4 экземпляра Колеса. 
Двигатель и колЕса отдельно от автомобиля существовать не могут. 

![[composition.png]]

**Агрегация**. Допустим к этому авто мы добавляем Елочку, которую в нем можно повесить. Но эта Елочка передается в класс автомобиль откуда-то извне. То есть она может использоваться где угодно и существовать сама по себе. 

![[agregation.png]]

## Абстрактные классы и интерфейсы
**Интерфейс** – как оглавление в учебнике. Он говорит ЧТО надо сделать, но не говорит КАК это сделать. Также из интерфейса нельзя сделать объект. 

**Абстрактные классы** похожи на интерфейс, в них также можно объявлять абстрактные методы, которые будут аналогом методов интерфейса (то есть у них не будет реализации).  При этом в абстрактных классах можно создавать и обычные методы с какой-то реализацией и логикой. 
И класс, который будет наследоваться на абстрактного, унаследует все обычные методы и также должен будет реализовывать методы абстрактные, то есть в них должны быть какая-то логика.

Интерфейсы на практике встречаются чаще. 

Унаследоваться мы можем только от одного класса, а имплементировать можем неограниченное кол-во интерфейсов. 

![[interface.png]]

То есть наследуя один интерфейс, разные классы могут по-своему его реализовывать.
С помощью интерфейсов можем писать более гибкий код, достигать более гибкого полиморфизма и в первую очередь систему необходимо проектировать именно на уровне интерфейсов. 